name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.pwc-retail-etl.com
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
    
    - name: Set up environment variables
      run: |
        echo "DEPLOY_TAG=${GITHUB_SHA:0:7}" >> $GITHUB_ENV
        echo "ENVIRONMENT=staging" >> $GITHUB_ENV
    
    - name: Deploy to staging server
      run: |
        echo "ðŸš€ Deploying to staging environment..."
        echo "Image tag: ${{ env.DEPLOY_TAG }}"
        
        # Create deployment script
        cat > deploy-staging.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Starting staging deployment..."
        
        # Update environment file
        cat > .env.staging << ENVEOF
        ENVIRONMENT=staging
        DATABASE_TYPE=postgresql
        DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
        API_HOST=0.0.0.0
        API_PORT=8000
        TYPESENSE_API_KEY=${{ secrets.STAGING_TYPESENSE_API_KEY }}
        TYPESENSE_HOST=typesense-staging
        TYPESENSE_PORT=8108
        ENABLE_EXTERNAL_ENRICHMENT=true
        ENABLE_VECTOR_SEARCH=true
        ENABLE_MONITORING=true
        SLACK_WEBHOOK_URL=${{ secrets.STAGING_SLACK_WEBHOOK }}
        ENVEOF
        
        # Pull latest images
        docker-compose -f docker-compose.production.yml pull
        
        # Stop existing containers
        docker-compose -f docker-compose.production.yml down
        
        # Start new containers
        docker-compose -f docker-compose.production.yml up -d
        
        # Wait for services to be ready
        sleep 30
        
        # Run health checks
        echo "Running health checks..."
        curl -f http://localhost:8000/api/v1/health || exit 1
        
        echo "âœ… Staging deployment completed successfully!"
        EOF
        
        chmod +x deploy-staging.sh
        ./deploy-staging.sh
    
    - name: Run integration tests
      run: |
        echo "ðŸ§ª Running integration tests against staging..."
        
        # Wait for services to be fully ready
        sleep 10
        
        # Test API endpoints
        curl -f http://localhost:8000/api/v1/health || exit 1
        curl -f -u admin:${{ secrets.STAGING_API_PASSWORD }} http://localhost:8000/api/v1/sales || exit 1
        
        # Test ETL pipeline (if running)
        docker-compose -f docker-compose.production.yml exec -T etl python scripts/run_etl.py --dry-run || echo "ETL test skipped"
        
        echo "âœ… Integration tests passed!"
    
    - name: Notify deployment status
      run: |
        echo "ðŸ“¢ Notifying deployment status..."
        # Add Slack/email notification here
        echo "Staging deployment completed at $(date)"

  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment:
      name: production
      url: https://pwc-retail-etl.com
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
    
    - name: Set up environment variables
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "DEPLOY_TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
        else
          echo "DEPLOY_TAG=${GITHUB_SHA:0:7}" >> $GITHUB_ENV
        fi
        echo "ENVIRONMENT=production" >> $GITHUB_ENV
    
    - name: Deploy to production server
      run: |
        echo "ðŸš€ Deploying to production environment..."
        echo "Image tag: ${{ env.DEPLOY_TAG }}"
        
        # Create production deployment script
        cat > deploy-production.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Starting production deployment..."
        
        # Backup current deployment
        echo "Creating backup..."
        docker-compose -f docker-compose.production.yml exec -T postgres pg_dump -U postgres retail_db > backup-$(date +%Y%m%d-%H%M%S).sql || echo "Backup skipped"
        
        # Update environment file
        cat > .env.production << ENVEOF
        ENVIRONMENT=production
        DATABASE_TYPE=postgresql
        DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
        API_HOST=0.0.0.0
        API_PORT=8000
        TYPESENSE_API_KEY=${{ secrets.PRODUCTION_TYPESENSE_API_KEY }}
        TYPESENSE_HOST=typesense-production
        TYPESENSE_PORT=8108
        ENABLE_EXTERNAL_ENRICHMENT=true
        ENABLE_VECTOR_SEARCH=true
        ENABLE_MONITORING=true
        SLACK_WEBHOOK_URL=${{ secrets.PRODUCTION_SLACK_WEBHOOK }}
        ENVEOF
        
        # Pull latest images
        docker-compose -f docker-compose.production.yml pull
        
        # Rolling update - update one service at a time
        echo "Performing rolling update..."
        
        # Update API service
        docker-compose -f docker-compose.production.yml up -d --no-deps api
        sleep 20
        curl -f http://localhost:8000/api/v1/health || exit 1
        
        # Update ETL service
        docker-compose -f docker-compose.production.yml up -d --no-deps etl
        
        # Update other services
        docker-compose -f docker-compose.production.yml up -d
        
        echo "âœ… Production deployment completed successfully!"
        EOF
        
        chmod +x deploy-production.sh
        ./deploy-production.sh
    
    - name: Run production health checks
      run: |
        echo "ðŸ¥ Running production health checks..."
        
        # Wait for all services to be ready
        sleep 30
        
        # Comprehensive health checks
        curl -f http://localhost:8000/api/v1/health || exit 1
        curl -f -u admin:${{ secrets.PRODUCTION_API_PASSWORD }} http://localhost:8000/api/v1/health/detailed || exit 1
        
        # Test database connectivity
        docker-compose -f docker-compose.production.yml exec -T api python -c "
        import sys
        sys.path.insert(0, 'src')
        from data_access.db import get_database_url
        print('âœ… Database connectivity verified')
        " || exit 1
        
        # Test monitoring endpoints
        curl -f http://localhost:8000/api/v1/monitoring/metrics || exit 1
        
        echo "âœ… Production health checks passed!"
    
    - name: Run smoke tests
      run: |
        echo "ðŸ’¨ Running smoke tests..."
        
        # Test critical business functionality
        curl -f -u admin:${{ secrets.PRODUCTION_API_PASSWORD }} http://localhost:8000/api/v1/sales/summary || exit 1
        curl -f -u admin:${{ secrets.PRODUCTION_API_PASSWORD }} http://localhost:8000/api/v1/customers/summary || exit 1
        
        echo "âœ… Smoke tests passed!"
    
    - name: Update deployment tracking
      run: |
        echo "ðŸ“‹ Updating deployment tracking..."
        echo "Deployment tag: ${{ env.DEPLOY_TAG }}" >> deployment-log.txt
        echo "Deployment time: $(date)" >> deployment-log.txt
        echo "Environment: production" >> deployment-log.txt
        echo "---" >> deployment-log.txt
    
    - name: Notify production deployment
      run: |
        echo "ðŸ“¢ Notifying production deployment..."
        # Add production notification here
        echo "ðŸŽ‰ Production deployment completed successfully!"
        echo "Version: ${{ env.DEPLOY_TAG }}"
        echo "Time: $(date)"

  rollback:
    runs-on: ubuntu-latest
    if: failure()
    environment:
      name: production
    
    steps:
    - name: Rollback deployment
      run: |
        echo "âš ï¸ Deployment failed, initiating rollback..."
        
        # Rollback script
        cat > rollback.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Rolling back to previous version..."
        
        # Get previous successful deployment tag
        PREVIOUS_TAG=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep production-api | head -2 | tail -1 | cut -d: -f2)
        
        if [ ! -z "$PREVIOUS_TAG" ]; then
          echo "Rolling back to tag: $PREVIOUS_TAG"
          
          # Update docker-compose with previous images
          sed -i "s|:main-.*|:$PREVIOUS_TAG|g" docker-compose.production.yml
          
          # Restart services with previous images
          docker-compose -f docker-compose.production.yml up -d
          
          # Wait and verify
          sleep 20
          curl -f http://localhost:8000/api/v1/health || exit 1
          
          echo "âœ… Rollback completed successfully!"
        else
          echo "âŒ No previous version found for rollback"
          exit 1
        fi
        EOF
        
        chmod +x rollback.sh
        ./rollback.sh
    
    - name: Notify rollback
      run: |
        echo "ðŸ“¢ Deployment rollback completed"
        # Add rollback notification here